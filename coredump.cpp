Segmentation fault occur when a program attempts to access memory not allowed.
This is often caused by improper usage of pointers in the source code, 
dereferencing a null pointer as shown in the example below.

/* bad.c */

int bad(int *pt)
{
  int x = *pt;
  return x;
}

int main()
{
  int *ptr = 0;   /* null pointer */
  return bad(ptr);
}

$ gcc -g -o ./bad bad.c
$ ./bad
Segmentation fault
$ ls
bad  bad.c

no core file generated
why 
bcoz we not set ulimit -c

do it
$ ulimit -c
0
$ ulimit -c unlimited
$ ulimit -c
unlimited

run again
$ ./bad
Segmentation fault (core dumped)
$ ls
bad  bad.c  core.2333

$ gdb ./bad core.2333
GNU gdb (GDB) Fedora (7.5.1-37.fc18)
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
...
Reading symbols from /home/KHong/Work/Debug/bad...done.
[New LWP 2333]
Core was generated by `./bad'.
Program terminated with signal 11, Segmentation fault.
#0  0x00000000004004f8 in bad (pt=0x0) at bad.c:5
5	  int x = *pt;
(gdb) backtrace
#0  0x00000000004004f8 in bad (pt=0x0) at bad.c:5
#1  0x000000000040051e in main () at bad.c:12
(gdb) 

